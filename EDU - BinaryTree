package projetoArvore;

public class BinaryTree {

	private BinaryNode root;

	public void add(int info) {

		/**
		 * Metodo para adicionar um no a arvore binaria ordenada
		 */
		BinaryNode newNode = new BinaryNode(info); // Cria um no com o valor
													// recebido

		if (root == null) { // Verifica se a raiz esta vazia
			root = newNode; // Caso esteja, o no sera a raiz
			System.out.println("Raiz adicionada");
		} else {// Caso nao esteja vazia
			BinaryNode aux = root; // Cria um no aux para percorrer a arvore
			while ((aux != null) && (aux.getInfo() != info)) { // Verfica se o
																// no aux e
																// vazio e se a
																// info ja
																// existe na
																// arvore
				if (info < aux.getInfo()) { // Verifica se o no inserido e menor
											// que a raiz
					if (aux.getLeft() == null) { // Verifica se o no a esquerda
													// esta vazio
						aux.setLeft(newNode); // Caso seja entao sera adicionado
												// a esquerda da raiz
						System.out.println("Adicionado a esquerda");
						break;
					} else {// Caso nao esteja vazio
						aux = aux.getLeft();// Aponta o no aux para o no a
											// esquerda da raiz
						System.out.println("Entrou left else");
					}
				} else {// No inserido e maior que a raiz
					if (aux.getRight() == null) { // Verifica se o no a direita
													// esta vazio
						aux.setRight(newNode);// Caso esteja entao sera
												// adicionado a direita da raiz
						System.out.println("Adicionado a direita");
						break;
					} else {// Caso nao esteja vazio
						aux = aux.getRight();// Aponta o no aux para o no a
												// direita da raiz
						System.out.println("Entrou right else");
					}
				}
			}
		}
	}

	public BinaryNode search(int info) {
		/**
		 * Metodo para encontrar o no desejado
		 */

		if (this.exist(info)) {
			BinaryNode aux = root; // Aponta o no aux para a raiz
			while (aux != null) { // Verifica se o aux nao e nulo
				if (aux.getInfo() == info) { // Caso o valor do aux seja igual
												// ao
												// valor recebido
					return aux;
				} else {
					if (info < aux.getInfo()) { // Verifica se o valor recebido
												// e
												// menor que o valor do aux
						aux = aux.getLeft(); // Se for, entao aponta o aux para
												// a
												// esquerda do aux anterior
					} else {
						aux = aux.getRight();// Caso contrario, aponta o aux
												// para a
												// direita do aux anterior
					}
				}
			}

		}
		return null;
	}

	public boolean exist(int info) {
		/**
		 * Metodo para verificar se o no existe na arvore
		 * 
		 */
		BinaryNode aux = root; // Aponta o no aux para a raiz
		while (aux != null) { // Verifica se o aux nao e nulo
			if (aux.getInfo() == info) { // Caso o valor do aux seja igual ao
											// valor recebido
				return true;
			} else {
				if (info < aux.getInfo()) { // Verifica se o valor recebido e
											// menor que o valor do aux
					aux = aux.getLeft(); // Se for, entao aponta o aux para a
											// esquerda do aux anterior
				} else {
					aux = aux.getRight();// Caso contrario, aponta o aux para a
											// direita do aux anterior
				}
			}
		}
		return false;

	}

	public BinaryNode remove(int info) {
		if (root == null) {
			return null;
		} else if (root.getInfo() == info) {
			if (root.getLeft() == null) { // return ou root = root.getright( ) ?
				return root.getRight();
			} else {
				this.removalProcess(root); // realiza o processo apartir da raiz
			}
		} else {
			// this.search(info); tentar fazer com o metodo search dps
			BinaryNode father, aux;
			aux = root;
			father = aux;
			while (aux != null && aux.getInfo() != info) {
				father = aux;
				if (info > aux.getInfo()) {
					aux = aux.getRight();
				} else {
					aux = aux.getLeft();
				}
			}
			if (aux != null && father != null) {
				if (father.getLeft() == aux) {
					father.setLeft(this.removalProcess(aux));
				} else {
					father.setRight(this.removalProcess(aux));
				}
			}
		}
		return root;
	}

	public BinaryNode removalProcess(BinaryNode node) {
		BinaryNode father, aux;
		father = node;
		aux = father.getLeft();
		if (aux != null) {
			while (aux.getRight() != null) {
				father = aux;
				aux = aux.getRight();
			}
			node.setInfo(aux.getInfo());
			node.setLeft(null);
			//father.setRight(aux.getLeft()); 
		} else {
			node = null;
		}

		return node;
	}

	public void printPreOrder() {
		this.startPrintPreOrder(root);
	}

	private void startPrintPreOrder(BinaryNode node) {
		if (node != null) {
			System.out.println(node.getInfo());
			this.startPrintPreOrder(node.getLeft());
			this.startPrintPreOrder(node.getRight());
		}
	}

	public static void main(String[] Args) {
		BinaryTree bt = new BinaryTree();
		bt.add(0);
		bt.add(10);
		bt.add(-8);
		bt.add(-15);
		bt.add(-6);
		bt.add(5);
		bt.add(0);
		bt.add(12);
		bt.add(-20);
		bt.add(-10);
		bt.add(-7);
		bt.add(-4);
		bt.add(2);
		bt.add(8);
		bt.add(11);
		bt.add(13);
		bt.add(-5);
		bt.add(-2);
		bt.add(1);
		bt.add(3);
		bt.add(6);
		bt.add(9);
		bt.add(-3);
		bt.add(-1);

		System.out.println(bt.remove(-4));

		System.out.println(bt.exist(0));
		System.out.println(bt.exist(10));
		System.out.println(bt.exist(-8));
		System.out.println(bt.exist(-15));
		System.out.println(bt.exist(-6));
		System.out.println(bt.exist(12));
		System.out.println(bt.exist(2));
		System.out.println(bt.exist(6));
		System.out.println(bt.exist(1));
		System.out.println(bt.exist(3));
		System.out.println(bt.exist(8));
		System.out.println(bt.exist(9));
		System.out.println(bt.exist(11));
		System.out.println(bt.exist(13));
		System.out.println(bt.exist(-20));
		System.out.println(bt.exist(-10));
		System.out.println(bt.exist(-7));
		System.out.println(bt.exist(-5));
		System.out.println(bt.exist(-1));
		System.out.println(bt.exist(-2));
		System.out.println(bt.exist(-3));
		System.out.println(bt.exist(-4));
		System.out.println(bt.exist(5));

		System.out.println(bt.search(0));

		bt.printPreOrder();

	}

}
