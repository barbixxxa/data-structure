package projetoArvore;

import java.util.Scanner;

public class BinaryTree {

	private BinaryNode root;

	public void add(int info) {

		/**
		 * Metodo para adicionar um no a arvore binaria ordenada
		 */
		BinaryNode newNode = new BinaryNode(info); // Cria um no com o valor
													// recebido

		if (root == null) { // Verifica se a raiz esta vazia
			root = newNode; // Caso esteja, o no sera a raiz
			System.out.println("Raiz adicionada");
		} else {// Caso nao esteja vazia
			BinaryNode aux = root; // Cria um no aux para percorrer a arvore
			while ((aux != null) && (aux.getInfo() != info)) { // Verfica se o
																// no aux e
																// vazio e se a
																// info ja
																// existe na
																// arvore
				if (info < aux.getInfo()) { // Verifica se o no inserido e menor
											// que a raiz
					if (aux.getLeft() == null) { // Verifica se o no a esquerda
													// esta vazio
						aux.setLeft(newNode); // Caso seja entao sera adicionado
												// a esquerda da raiz
						System.out.println("Adicionado a esquerda");
						break;
					} else {// Caso nao esteja vazio
						aux = aux.getLeft();// Aponta o no aux para o no a
											// esquerda da raiz
						System.out.println("Entrou left else");
					}
				} else {// No inserido e maior que a raiz
					if (aux.getRight() == null) { // Verifica se o no a direita
													// esta vazio
						aux.setRight(newNode);// Caso esteja entao sera
												// adicionado a direita da raiz
						System.out.println("Adicionado a direita");
						break;
					} else {// Caso nao esteja vazio
						aux = aux.getRight();// Aponta o no aux para o no a
												// direita da raiz
						System.out.println("Entrou right else");
					}
				}
			}
		}
	}

	public BinaryNode search(int info) {
		/**
		 * Metodo para encontrar o no desejado
		 */

		if (this.exist(info)) {
			BinaryNode aux = root; // Aponta o no aux para a raiz
			while (aux != null) { // Verifica se o aux nao e nulo
				if (aux.getInfo() == info) { // Caso o valor do aux seja igual
												// ao
												// valor recebido
					return aux;
				} else {
					if (info < aux.getInfo()) { // Verifica se o valor recebido
												// e
												// menor que o valor do aux
						aux = aux.getLeft(); // Se for, entao aponta o aux para
												// a
												// esquerda do aux anterior
					} else {
						aux = aux.getRight();// Caso contrario, aponta o aux
												// para a
												// direita do aux anterior
					}
				}
			}

		}
		return null;
	}

	public boolean exist(int info) {
		/**
		 * Metodo para verificar se o no existe na arvore
		 * 
		 */
		BinaryNode aux = root; // Aponta o no aux para a raiz
		while (aux != null) { // Verifica se o aux nao e nulo
			if (aux.getInfo() == info) { // Caso o valor do aux seja igual ao
											// valor recebido
				return true;
			} else {
				if (info < aux.getInfo()) { // Verifica se o valor recebido e
											// menor que o valor do aux
					aux = aux.getLeft(); // Se for, entao aponta o aux para a
											// esquerda do aux anterior
				} else {
					aux = aux.getRight();// Caso contrario, aponta o aux para a
											// direita do aux anterior
				}
			}
		}
		return false;

	}

	public BinaryNode remove(int info) {
		if (root == null) {
			return null;
		} else if (root.getInfo() == info) {
			if (root.getLeft() == null) { // return ou root = root.getright( ) ?
				root = root.getRight();
				return root;
			} else {
				this.removalProcess(root); // realiza o processo apartir da raiz
			}
		} else {
			// this.search(info); tentar fazer com o metodo search dps
			BinaryNode father, aux;
			aux = root;
			father = aux;
			while (aux != null && aux.getInfo() != info) {
				father = aux;
				if (info > aux.getInfo()) {
					aux = aux.getRight();
				} else {
					aux = aux.getLeft();
				}
			}
			if (aux != null && father != null) {
				if (father.getLeft() == aux) {
					father.setLeft(this.removalProcess(aux));
				} else {
					father.setRight(this.removalProcess(aux));
				}
			}
		}
		return root;
	}

	private BinaryNode removalProcess(BinaryNode node) {
		BinaryNode father, aux;
		father = node;
		aux = father.getLeft();
		if (aux != null) {
			while (aux.getRight() != null) {
				father = aux;
				aux = aux.getRight();
			}
			node.setInfo(aux.getInfo());// TODO bugando aqui
			father.setRight(aux.getLeft());
		} else {
			node = null;
		}

		return node;
	}

	public void printPreOrder() {
		this.startPrintPreOrder(root);
	}

	private void startPrintPreOrder(BinaryNode node) {
		if (node != null) {
			System.out.println(node.getInfo());
			this.startPrintPreOrder(node.getLeft());
			this.startPrintPreOrder(node.getRight());
		}
	}

	public void organize() {
		if (root != null) {

		}
	}

	public static void main(String[] Args) {
		BinaryTree bt = new BinaryTree();
		Scanner sc = new Scanner(System.in);
		int x = 0;

		do {
			System.out.println("\nEscolha uma opcao: ");
			System.out
					.println("1: Adicionar um no a arvore \n" + "2: Excluir um no\n" + "3: Verificar se existe um no\n"
							+ "4: Procurar um no\n" + "5: Printar a arvore em pre ordem\n" + "9: Sair");

			switch (x = sc.nextInt()) {
			case 1:
				bt.add(sc.nextInt());
				break;
			case 2:
				bt.remove(sc.nextInt());
				break;
			case 3:
				System.out.println(bt.exist(sc.nextInt()));
				break;
			case 4:
				System.out.println(bt.search(sc.nextInt()));
				break;
			case 5:
				bt.printPreOrder();
				break;
			case 9:
				x = 0;
				break;

			}

		} while (x != 0);

	}
}
